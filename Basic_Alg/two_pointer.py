# 투 포인터
# => 리스트 내 원소에 음수 데이터가 있으면 활용 X

'''
* 특정한 합을 가지는 부분 "연속 수열" 찾기
* 정렬되어 있는 두 리스트의 합집합 = 병렬 정합(= Merge Sort)

부분 연속 수열 중에서 '특정한 합(M)'을 갖는 수열의 개수 찾기
1. 시작점start 과 끝점end이 첫 번째 원소의 인덱스(0)을 가리키도록 한다
2. 현재 부분합이 M과 같다면 카운트 한다.
3. 현재 부분합이 M보다 작으면 end를 1 증가시킨다.
4. 현재 부분합이 M보다 크거나 같으면 start를 1 증가시킨다
5. 모든 경우를 확인할 때까지 2번부터 4번까지 과정을 반복
'''

# 특정한 합을 가지는 부분 "연속 수열" 찾기 #
# start를 오른쪽으로 이동시키면 항상 합이 감소하고, end를 오른쪽으로 이동시키면 항상
# 합이 증가하기 때문에 투 포인터 알고리즘으로 문제를 해결할 수 있음

n = 5 # 데이터의 개수 = start
m = 5 # 찾고자 하는 부분합 M

data = [1, 2, 3, 2, 5]

# 각 값 초기화
cnt = 0
interval_sum = 0
end = 0

# start를 차례대로 증가시키며 반복
for s in range(n): # 0 1 2 3 4
    while interval_sum < m and end < n:
        # end는 인덱스 값
        interval_sum += data[end]
        end += 1

    if interval_sum == m:
        cnt += 1
    # print("합", interval_sum)
    interval_sum -= data[s]

print(cnt)

# 정렬되어 있는 두 리스트의 합집합 #
# 이미 정렬되어 있는 2개의 리스트가 입렵으로 주어지고 이때 두 리스트의 모든 원소를 합쳐서
# 정렬한 결과를 계산

'''
1. 주어진 정렬된 두 리스트에서 처리되지 않은 원소 중 가장 작은 원소를 i, j가 가르키도록 한다
2. A[i], B[j] 중에서 더 작은 원소를 결과 리스트에 담는다.
3. 리스트 A, B에서 더 이상 처리할 원소가 없을 때까지 1번과 2번을 반복
'''

n, m = 3, 4

a = [1,3,5]
b = [2,4,6,8]

# 합집합 리스트 초기화 및 리스트 인덱스 i, j 값 초기화
res = [0] * (n+m)
i = 0 # n
j = 0 # m

# res 인덱스 값
k = 0

# or => 두 리스트 길이가 같지 않을 수 있음
while i < n or j < m:
    
    if j >= m or (i < n and a[i] <= b[j]):
        # 리스트 res 값 적용
        res[k] = a[i]
        i += 1

    else:
        res[k] = b[j]
        j += 1

    # res 인덱스 값 증가
    k += 1

print(res) # [1, 2, 3, 4, 5, 6, 8] / end=' ' => 줄바꿈 무시
for i in res:
    print(i, end=" ")